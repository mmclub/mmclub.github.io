<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 林翔宇 | 南京邮电大学移动互联网俱乐部]]></title>
  <link href="http://mmclub.github.io/blog/categories/lin-xiang-yu/atom.xml" rel="self"/>
  <link href="http://mmclub.github.io/"/>
  <updated>2014-06-08T11:03:12+08:00</updated>
  <id>http://mmclub.github.io/</id>
  <author>
    <name><![CDATA[MMClub]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[部署Django Application（一）使用CentOS + Nginx + Gunicorn + Supervisord]]></title>
    <link href="http://mmclub.github.io/blog/2014/06/08/deploy-django-application-1/"/>
    <updated>2014-06-08T10:58:53+08:00</updated>
    <id>http://mmclub.github.io/blog/2014/06/08/deploy-django-application-1</id>
    <content type="html"><![CDATA[<p>作者: 林翔宇</p>

<p>本文是去年做<a href="https://github.com/mmclub/nupter-server-v1">掌上南邮第一版服务器程序</a>的时候写的部署笔记，原来放在<a href="http://jianshu.io/p/bNJWEs">简书</a>上，时隔一年后，还收到一两个喜欢，看来还有那么一点点价值，于是就搬过来好了。</p>

<h2>初始化服务器环境</h2>

<pre><code>yum -y install vim git screen python-pip
curl -L https://github.com/robbyrussell/oh-my-    zsh/raw/master/tools/install.sh | sh
pip install virtualenvwrapper gunicorn django
mkdir /usr/local/virtualenv
mkvirtualenv python
</code></pre>

<h2>配置gunicorn服务器</h2>

<p>Gunicorn(gunicorn.org)是一个Python WSGI UNIX的HTTP服务器。，从Ruby的独角兽（Unicorn）项目移植。</p>

<p>在Django项目下建立shell脚本</p>

<pre><code>#!/bin/bash
set -e 
LOGFILE=guni.log
LOGDIR=$(dirname $LOGFILE)
NUM_WORKERS=3  # cpu core nums * 2 + 1
USER=nobody
GROUP=nogroup
# WORKER=gevent # install python gevent
ADDRESS=127.0.0.1:8000
test -d $LOGDIR || mkdir -p $LOGDIR
exec gunicorn_django -w $NUM_WORKERS --bind=$ADDRESS \
 # -k $WORKER 
  --daemon \
  --user=$USER --group=$GROUP --log-level=error \
  --log-file=$LOGFILE 2&gt;&gt;$LOGFILE
</code></pre>

<h2>安装Nginx用作反向代理与静态服务器</h2>

<ul>
<li>使用<a href="http://lnmp.org/">http://lnmp.org/</a> 安装Nginx</li>
<li>用Lnmp一键安装包带的脚本新建一个虚拟主机</li>
<li><p>更改主机的Nginx配置文件</p>

<pre><code>  server {

      listen       80;
      server_name  nuptapi.nupter.org;
      access_log   /home/wwwlogs/nuptapi.nupter.org.log;
      error_log    /home/wwwlogs/nuptapi.nupter.org.error.log;
      root /home/wwwroot/nuptapi.nupter.org;

      location  /static/ {
          alias /home/wwwroot/nuptapi.nupter.org/static/;
      }

      location  / {
          proxy_pass            http://127.0.0.1:8000;
          proxy_redirect        off;
          proxy_set_header      Host             $host;
          proxy_set_header      X-Real-IP        $remote_addr;
          proxy_set_header      X-Forwarded-For  $proxy_add_x_forwarded_for;
          client_max_body_size  10m;
      }

  }
</code></pre></li>
</ul>


<h2>用Supervisord守护进程</h2>

<ul>
<li>echo_supervisord_conf > /etc/supervisord.conf</li>
<li>vim /etc/supervisord.conf</li>
</ul>


<p>更改配置文件以下的内容</p>

<ul>
<li>chown=lxy:lxy       ; socket file uid:gid owner</li>
<li><p>[program:nuptapi]
  command=/home/wwwroot/django_helloworld/gunicorn_start.sh</p></li>
<li><p>Shell运行supervisord</p></li>
<li>同时supervisord 默认会在9001端口打开一个HTTP服务器，可以在Nginx再配置一个反向代理来远程登陆</li>
</ul>


<h2>其它</h2>

<ul>
<li>配置DNS服务器，解析域名A记录到服务器IP</li>
<li>重启Nginx</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于某App外包开发心得－iOS篇（一）]]></title>
    <link href="http://mmclub.github.io/blog/2014/06/01/think-of-a-outsourcing-app-ios-develpment-1/"/>
    <updated>2014-06-01T10:26:47+08:00</updated>
    <id>http://mmclub.github.io/blog/2014/06/01/think-of-a-outsourcing-app-ios-develpment-1</id>
    <content type="html"><![CDATA[<ul>
<li>作者 ： 林翔宇</li>
</ul>


<p>前不久和朋友一起合作了一个外包App项目，我负责iOS和后台Server，另外两名同学合作开发Android端。现在项目已经进入收尾上架工作，我将就开发过程中的一些感想与收获进行总结。</p>

<h2>使用CocoaPods做依赖管理以及开发用到的第三方开源项目</h2>

<p>CocoaPods真是依赖管理神器，比Andorid的Maven或者Gradle方便多了。具体试用可以看看这篇文章<a href="http://blog.devtang.com/blog/2014/05/25/use-cocoapod-to-manage-ios-lib-dependency/">唐巧－用CocoaPods做iOS程序的依赖管理
</a></p>

<p>而且最近CocoaPods的Spec有了第三方国内镜像，速度快多了，为什么之前开发的时候木有，加一个库要等半天(ノДＴ) 。 所以我之前修改Podfile后是这样更新的（不更新Spec库并且有提示）：</p>

<p><code>
pod install --verbose --no-repo-update   
</code></p>

<p>我项目里面的第三方依赖有：</p>

<p>```</p>

<pre><code>#import &lt;AVOSCloud/AVOSCloud.h&gt; // AVOSCloud SDK
#import &lt;MAMapKit/MAMapKit.h&gt;   // 高德地图
#import &lt;AFNetworking/AFNetworking.h&gt; // AFNetworking 网络通信   

#import &lt;UIColor+ChineseColor.h&gt; // 自己的项目复用模块
#import &lt;MMCommon/MMCommon.h&gt;  

#import &lt;SVProgressHUD/SVProgressHUD.h&gt; // 加载提示的HUD

#import &lt;Underscore.m/Underscore.h&gt; // Objective-C的类似JavaScript的Underscore.js的辅助库

#import &lt;UMengAnalytics/MobClick.h&gt;  // 友盟统计和SNS集成
#import &lt;TencentOpenAPI/TencentApiInterface.h&gt;
#import &lt;TencentOpenAPI/QQApiInterface.h&gt;
#import &lt;TencentOpenAPI/TencentOAuth.h&gt;
#import &lt;UMengSocial/UMSocialData.h&gt;
#import &lt;UMengSocial/UMSocialSnsService.h&gt;

#import &lt;SDWebImage/UIButton+WebCache.h&gt; // 异步图片加载
#import &lt;SDWebImage/UIImage+GIF.h&gt;
#import &lt;SDWebImage/UIImageView+WebCache.h&gt;
#import &lt;SDWebImage/UIImageView+WebCache.h&gt;
</code></pre>

<p>```</p>

<p>不得不提的是使用中。。友盟以及SNS集成过程中，不够清楚的文档以及那些坑的地方，还有调试了几天才发现是SDK悄悄升级，之前的SDK不能用的情况。</p>

<p>在使用的时候，为了更优雅的进行依赖管理，我也为高德地图和友盟SNS创建了Podfile并且提交到了CocoaPods/Spec库里面，需要的童鞋可以看看<a href="https://github.com/oa414/Specs/commits/master">https://github.com/oa414/Specs/commits/master</a></p>

<p>我们同时用了AVOSCloud与友盟，这两个第三方开发者平台功能有很多重复，但是当前各有长处。未来可能迁移到其中一个。</p>

<h2>iOS MVC与界面布局的一些实践</h2>

<p>最初的时候，为了快速开发，全部使用了Storyboard，这让我在一个小时就把几十个页面跳转关系全部做好了。。。而且可以作为原型演示给UI童鞋和Android童鞋看。到后来，发现Storyboard管理几十个页面完全是坑，很多东西代码写更方便，并且即使是23寸的显示器在Interface Building里面拖动各个View也好麻烦。。。于是把这个Tab布局的应用按照五个Tab拆成五个StoryBoard了。主要用代码做布局和跳转，同时取巧用了StoryBoard一些方便的地方。</p>

<p>把各个Tab对应内容分离到不同的StoryBoard的方法：（代码好丑）</p>

<p>```</p>

<p>+(UIViewController <em>)initViewController :(NSString </em>)storyBoardName</p>

<pre><code>                        identifier:(NSString *)identifier
                          iconName:(NSString *)iconName
                             withTag:(int) tag{

UIViewController *vc = [SXAppDelegate viewControllerWithStoryBoard:storyBoardName identifier:identifier];
UINavigationController *nav = [[UINavigationController alloc] initWithRootViewController:vc];

[nav.tabBarItem setImage:[SXAppDelegate getIconImage:iconName]];

nav.tabBarItem.image = [[SXAppDelegate getIconImage:iconName] imageWithRenderingMode:UIImageRenderingModeAlwaysOriginal];


UIImage *selectImage = [SXAppDelegate getIconPressedImage:iconName];
selectImage = [selectImage imageWithRenderingMode:UIImageRenderingModeAlwaysOriginal];
DebugLog(@"select Image %@", selectImage);
[nav.tabBarItem setSelectedImage:selectImage];
nav.tabBarItem.selectedImage = selectImage;
[[UITabBar appearance] setTintColor:[SXAppDelegate getNavColor:iconName]];

nav.tabBarItem.tag = tag;

[nav.tabBarItem setTitleTextAttributes:@{
                                        NSForegroundColorAttributeName : [SXAppDelegate getNavColor:iconName] }     forState:UIControlStateSelected];



NSDictionary *titles = @{
    @"home" : @"首页",
    @"product":@"产品",
    @"news": @"新闻",
    @"my": @"我的",
    @"more": @"更多",
};
[nav.tabBarItem setTitle:titles[iconName]];
return nav;
</code></pre>

<p>}</p>

<pre><code>self.tabBarController = [[UITabBarController alloc] init];

self.regVC = [SXAppDelegate initViewController:@"My" identifier:@"login" iconName:@"my" withTag:3];
self.userVC = [SXAppDelegate initViewController:@"My" identifier:@"index" iconName:@"my" withTag:3];
self.indexVC = [SXAppDelegate initViewController:@"Main" identifier:@"index" iconName:@"home" withTag:0];
self.productVC = [SXAppDelegate initViewController:@"Product" identifier:@"index" iconName:@"product" withTag:1];
self.newsVC = [SXAppDelegate initViewController:@"News" identifier:@"index" iconName:@"news" withTag:2];
self.myVC = self.regVC;
self.moreVC = [SXAppDelegate initViewController:@"More" identifier:@"index" iconName:@"more" withTag:4];

DebugLog(@"Splash  %@", [SXSplashHelper splashImage]);

if ([SXUser currentUser] == nil){
    [self setRegView];
}else {
    [self setUserView];
}

self.window.rootViewController = self.tabBarController;
</code></pre>

<p>```</p>

<h2>宏</h2>

<p>有几个常用的宏可以和大家分享下：</p>

<p>Debug环境下输出Log与行号</p>

<p>```</p>

<h1>ifdef DEBUG</h1>

<h1>define DebugLog( s, &hellip; ) NSLog( @&ldquo;[FILE]%@ %<em>s [LINE]%&ndash;</em>d [METHOD]%@ %*s [MESSAGE]%@&rdquo;, [[NSString stringWithUTF8String:<strong>FILE</strong>] lastPathComponent],30 &ndash; ([[[NSString stringWithUTF8String:<strong>FILE</strong>] lastPathComponent] length]),&ldquo;&rdquo;, 5,<strong>LINE</strong>, NSStringFromSelector(<em>cmd), 75 &ndash; ([NSStringFromSelector(</em>cmd) length]),&ldquo;&rdquo;, [NSString stringWithFormat:(s), ##<strong>VA_ARGS</strong>] )</h1>

<h1>else</h1>

<h1>define DebugLog( s, &hellip; )</h1>

<p>```</p>

<p>用RGB生成UIColor</p>

<p>```</p>

<h1>define UIColorFromRGB(rgbValue) [UIColor \</h1>

<p>colorWithRed:((float)((rgbValue &amp; 0xFF0000) >> 16))/255.0 \
green:((float)((rgbValue &amp; 0xFF00) >> 8))/255.0 \
blue:((float)(rgbValue &amp; 0xFF))/255.0 alpha:1.0]
```</p>

<p>获取App版本号</p>

<p>```</p>

<h1>define APP_VERSION ([[NSBundle mainBundle] objectForInfoDictionaryKey: @&ldquo;CFBundleShortVersionString&rdquo;])</h1>

<p>```</p>

<p>判断是否是4寸Retina屏幕</p>

<p><code>
IS_IPHONE_5 ( fabs( ( double )[ [ UIScreen mainScreen ] bounds ].size.height - ( double )568 ) &lt; DBL_EPSILON )
</code></p>

<h2>让你事倍功半的开发工具</h2>

<p>我觉得有一个外接液晶屏幕很重要。。。</p>

<p>此外是一把比较好的椅子。。</p>

<p>此外，推荐大家试试<a href="http://revealapp.com/">http://revealapp.com/</a>, 一款帮你轻松调试界面的App，收费软件，有试用版本，可以免去改参数－编译－点击查看对应View－改参数－编译的麻烦流程，直接在Reveal里面修改参数就能看到对应效果</p>

<h2>iOS Developer账号的那些坑 与 提交审核</h2>

<h3>iOS Developer 账号</h3>

<p>如果希望认真学习开发iOS App，加入iOS开发者计划是必不可少的。当初为了真机调试，又是找破解Xcode的教程又是在淘宝上买开发者证书，最后还是靠亲爱的妈妈特地办了一张Visa信用卡乖乖付钱交了99美元年费。</p>

<p>但是并不是乖乖叫了钱就一番风顺了。创建一个应用，你需要在开发面板上分别配置开发者证书，应用ID，调试设备，推送证书。。。并且绑定对应调试设备和应用ID。。。推送证书还分开发设备的Sandbox环境和Production环境。。。</p>

<p>相关具体设置可以参见<a href="http://ryantang.me/blog/2013/11/28/apple-account-3/">苹果开发者账号那些事儿</a></p>

<h3>测试分发</h3>

<p>据说TestFlight很不错。。。最近被Apple收购了，我在使用过程中也感到各种不便。不过一些在应用内反馈给测试人员的特性还不错。</p>

<p>最后我发测试包用的是<a href="http://fir.im/">Fir.im</a>，感觉还不错。另外AVOS也提供了相应的功能，值得一试。</p>

<p>同时我也用一个晚上时间做了一个Android APK分发的Demo，放在 <a href="https://github.com/oa414/swan">Github</a>上，希望有空能完善。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android入门杂谈]]></title>
    <link href="http://mmclub.github.io/blog/2014/04/03/start-learning-android/"/>
    <updated>2014-04-03T00:29:07+08:00</updated>
    <id>http://mmclub.github.io/blog/2014/04/03/start-learning-android</id>
    <content type="html"><![CDATA[<p>作者: 林翔宇</p>

<h2>入门</h2>

<h3>配置环境</h3>

<ul>
<li>请在<a href="http://www.java.com/zh_CN/">官方网站</a>下载对应的JDK包安装。注意你的系统版本是32位还是64位的，分别下载对应的版本。如果是Windows用户，请尽量按默认选项安装，Mac / Linux用户请用对应的包管理工具安装。这一步出现问题，网上会有很多解决方案。</li>
<li>去<a href="http://developer.android.com/sdk/index.html">Android官方网站</a>下载Android Studio或者ADT Bundle, 分别对应基于Intellij IDLE和Eclipese的Andorid开发IDE，解压就能使用。</li>
</ul>


<h3>学习语言</h3>

<ul>
<li>你需要学习叫Java的一门编程语言，仅需入门，明白基础概念，并能写一些非常简单的小程序就可以了</li>
<li>学到哪里足够了呢？知道<code>if</code>, <code>for</code>, <code>while</code> , 分别是用来干什么的， 知道类，对象，方法是什么东东, 最好能理解抽象类(abtract class)和接口(interface)这种奇怪的东西存在的原因～</li>
<li>书籍推荐 《Head First Java》，适合有任意一门语言基础的，知道<code>if</code>, <code>for</code>, <code>while</code> 以及函数分别是用来干什么的孩子学习。</li>
<li>你并不用十分深入的去学习Java，可以在边学Android的同时学习Java，两者的学习相辅相成。注意：如果你只是想写Android或者Java语言本身，你不必去接触J2EE那些庞大的知识体系，那些和Android基本没什么关系。</li>
<li>不想用Java写Android？当然可以。

<ul>
<li> 你可以选择一些商业的第三方游戏引擎自带支持的语言写Android程序</li>
<li> 熟悉.Net? 试试 <a href="http://xamarin.com/monoforandroid">Xamarin.Android</a></li>
<li> 熟悉Scala或者Clojure? 这些基于JVM的语言也都有对应的写Android程序的方案</li>
<li> 是一个Web开发者? <a href="http://phonegap.com/">PhoneGap</a>, <a href="http://jquerymobile.com/">Jquery Mobile</a>等相关的开源框架在朝你招手。借助HTML5的新特性与强大的基于Webkit的浏览器内核，你也可以用Web前端技术写出不错的Andorid程序。</li>
<li>但是话说回来，绝大多数Android程序还是用Java进行开发，并且用Java开发Android的资料很多很多。所以，尽量还是使用Java吧～</li>
</ul>
</li>
</ul>


<h3>Android入门</h3>

<ul>
<li>官方网站有一整套的<a href="http://developer.android.com/training/index.html">Android Tranning 入门教程</a>, 质量很高而且都是官方的最佳实践，强烈建议一看。</li>
<li>当然官方教程门槛对于0基础的初学者还是有点高，此时建议买一本书学习Android的基本概念和基本入门。毕竟有本书的感觉是不一样的。。。推荐： Apress出版社，Wrox出版社， Orelly出版社的书，国内也引进了一些翻译版本。强烈建议看国外的书，至少能保证条理清晰。</li>
</ul>


<h2>入门到初步掌握</h2>

<p>我建议按照以下步骤来</p>

<ul>
<li>学习最基本的Android概念，会写Hello World，用XML写最简单的布局。</li>
<li>找一本cookbook类型的书，也就是每一小节都带你实现一个小小的功能，让你每次都能接触到新鲜的东西，比较有成就感，而且同时巩固基础。</li>
<li>整理Android概念，比如重新回过头看看<a href="http://developer.android.com/training/index.html">Android Tranning 入门教程</a>，搞明白Activity, Service, Content Provider, Broadcast到底是什么东西，比较熟练的掌握一些常用的功能，比如按钮点击时间，对话框提醒，文件保存，网络资源获取等等。</li>
<li>开始做一些小东西，阅读大量的优秀应用的源代码，学会使用开源库， 阅读<a href="http://developer.android.com/develop/index.html">Android Developer</a>的 Training, API Guide以及 Tools。具体哪个类不明白的话，就去Reference查</li>
<li>最后说一句，这只是个人实践得出来的感觉不算差的方法，我也打算尝试以另一种方式培训0基础的有兴趣的同学，具体的方法可以自己选择，但是我强烈建议2点

<ol>
<li>生命宝贵，有限的时间应该用来约漂亮姑娘(或泡帅哥)，游玩，享受人生，而不是贪图方便看一些国内无厘头或者水分很多的资料</li>
<li>你投入的时间和你的收获正相关，只要付出努力终有回报</li>
</ol>
</li>
</ul>


<h2>资源</h2>

<p>善于利用现有的资源，善于使用第三方开源库</p>

<ul>
<li><a href="https://github.com/">Github</a>  最热门的开源分享网站，你能找到很多<a href="https://github.com/search?q=android&amp;type=Repositories&amp;s=stars">高质量的Android开源库</a></li>
<li><a href="http://www.csdn.net/article/2013-05-03/2815127-Android-open-source-projects">这里</a>有一些第三方开源库的介绍</li>
<li><a href="http://www.appdevwiki.com/wiki/show/HomePage">App Dev Wiki</a></li>
<li><a href="http://www.androidviews.net/">Android Views</a></li>
<li><a href="http://www.theultimateandroidlibrary.com/">The Ultimate Android Library</a></li>
<li>国内最大的论坛应该是<a href="http://www.eoeandroid.com/">eoe</a>, 不过内容比较水。。我偶尔也会去<a href="http://www.oschina.net/android">开源中国</a>逛逛</li>
</ul>


<p>善于在网上寻找答案</p>

<ul>
<li>请务必使用Google而不是百度</li>
<li>学会使用<a href="http://stackoverflow.com/">stackoverflow</a>, 这里有几乎所有细节问题的解决方案</li>
</ul>


<p>善于获取最新资讯</p>

<ul>
<li>关注Google/Android官方的资讯</li>
<li>订阅<a href="http://androiddevweekly.com/">AndroidDevWeekly</a>,每周会发一封最新的资讯到邮箱</li>
</ul>


<h2>发布</h2>

<h3>用户追踪，反馈与推送通知</h3>

<p>用户追踪和反馈可以自己实现客户端功能与服务器端，也可以使用第三方的服务。比如<a href="http://www.umeng.com/">友盟</a>, <a href="https://www.parse.com/">Parse</a> 等。</p>

<p>因为谷歌很多服务，包括推送通知在大陆是被封掉的，建议使用<a href="http://www.jpush.cn/">极光推送</a>,<a href="https://www.parse.com/">Parse</a>的SDK。非常不建议用后台进程轮询的方法查询，费电费流量。</p>

<h3>发布之前</h3>

<ul>
<li>记得对应用进行签名</li>
<li><a href="http://mtc.baidu.com/">百度云测试</a>，<a href="http://www.testin.cn/portal.action?op=Portal.index">云测</a>可以帮你解决众多机型的测试问题</li>
</ul>


<h3>Android市场现状</h3>

<ul>
<li>国内发布Android应用很纠结，机锋，安卓，安智，木蚂蚁，应用汇等等。没有特别的方法，多注册几个账号吧。</li>
<li>强烈建议注册Google Play开发人员，应用无需审核马上就能上架，面向全球市场。注册需要VISA/Mastercard的国际信用卡，以及一次性25美金的费用。</li>
</ul>


<h2>盈利</h2>

<p>这里只谈个人开发者或业余小团队的盈利方式</p>

<p>Android国内收费应用市场很难发展，如果做游戏等应用可以考虑应用内购买的方式。普通应用的盈利方式有</p>

<ul>
<li>广告条。收入低，但是也是一种方式。国内有各种广告商，但是个人推荐<a href="https://zhcn.admob.com">Admob</a></li>
<li>做外包项目。通过关系网接外包项目，或者上<a href="http://elance.com/">Elance</a>，<a href="http://www.freelancer.com/">Freelancer</a>, <a href="https://www.odesk.com/">Odesk</a>接国外外包项目，十分不推荐上猪八戒这些国内网站接项目，市场规范程度和收入远低于国外</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to Install Ruby on Rails on CentOS 6.5 Using Rbenv]]></title>
    <link href="http://mmclub.github.io/blog/2014/03/30/install-ruby-on-rails-on-centos/"/>
    <updated>2014-03-30T11:11:37+08:00</updated>
    <id>http://mmclub.github.io/blog/2014/03/30/install-ruby-on-rails-on-centos</id>
    <content type="html"><![CDATA[<ul>
<li>Author: Lin Xiangyu</li>
</ul>


<h2>Introduction</h2>

<h3>Ruby on Rails</h3>

<p>Ruby on Rails is one of the most popular web development framework, it&rsquo;s build upon  Ruby Programming Language, and it&rsquo;s the hottest web development stack currently.</p>

<h3>Rbenv</h3>

<p><a href="https://github.com/sstephenson/rbenv">Rbenv</a> is a shell script tools created by <a href="http://sstephenson.us/">Sam Stephenson</a>. It&rsquo;s used for groom your app’s Ruby environment.Use rbenv can pick a Ruby version for your application and guarantee that your development environment matches production.</p>

<p>rbenv works by inserting a directory of shims at the front of your PATH:</p>

<pre><code> ~/.rbenv/shims:/usr/local/bin:/usr/bin:/bin
</code></pre>

<p>Through a process called rehashing, rbenv maintains shims in that directory to match every Ruby command across every installed version of Ruby—irb, gem, rake, rails, ruby, and so on.</p>

<h3>CentOS</h3>

<p>CentOS is derived from  Red Hat Enterprise Linux. The target users of these distributions are usually businesses, which require their systems to be running the most stable way for a long time.So we are going to use  CentOS 6.5 running our applications.</p>

<h2>Step One &ndash; Install dependencies</h2>

<p>Before, installing any package, it&rsquo;s always recommended to update package repository cache use yum.</p>

<pre><code> sudo yum update
</code></pre>

<p>Now,in order to get necessary development tools and dependencies, run the following:</p>

<pre><code> sudo yum groupinstall -y 'development tools'
 sudo yum install -y gcc-c++ glibc-headers openssl-devel readline libyaml-devel readline-devel zlib zlib-devel  sqlite-devel  
</code></pre>

<h2>Step Two &ndash; Install Rbenv and ruby-build</h2>

<p>Then we are ready to get Rbenv downloaded installed, run the following to check out rbenv into ~/.rbenv:</p>

<pre><code> git clone git://github.com/sstephenson/rbenv.git ~/.rbenv
</code></pre>

<p>Add ~/.rbenv/bin to your $PATH for access to the rbenv command-line utility:</p>

<pre><code> echo 'export PATH="$HOME/.rbenv/bin:$PATH"' &gt;&gt; ~/.bash_profile
</code></pre>

<p>Add rbenv init to your shell to enable rbenv shims and autocompletion.</p>

<pre><code> echo 'eval "$(rbenv init -)"' &gt;&gt; ~/.bash_profile
</code></pre>

<p>Ruby-build is a Rbenv plugin which provides the rbenv install command that simplifies the process of installing new Ruby versions. Install rbenv-build:</p>

<pre><code> git clone https://github.com/sstephenson/ruby-build.git ~/.rbenv/plugins/ruby-build
</code></pre>

<p>reloaded your bash_profile to enable rbenv command:</p>

<pre><code> source ~/.bash_profile
</code></pre>

<h2>Step Three &ndash; Install Ruby</h2>

<p>Install Ruby 2.1.0 and make it the default</p>

<pre><code> rbenv install 2.1.0
 rbenv rehash
 rbenv global 2.1.0
</code></pre>

<p>Now you can run:</p>

<pre><code> ruby -v
</code></pre>

<p>to verify your ruby environment has been installed successful。 It will output something like this:</p>

<pre><code> ruby 2.1.0p0 (2013-12-25 revision 44422) [x86_64-linux]
</code></pre>

<h2>Step Four &ndash; Install Nodejs</h2>

<p>Ruby on Rails need a JavaScript runtime support. It use <a href="https://github.com/sstephenson/execjs">execjs</a> gem which can automatically picks the best runtime available to evaluate your JavaScript program, then returns the result to you as a Ruby object.</p>

<p>ExecJS supports these runtimes:</p>

<ul>
<li>therubyracer &ndash; Google V8 embedded within Ruby</li>
<li>therubyrhino &ndash; Mozilla Rhino embedded within JRuby</li>
<li>Node.js</li>
<li>Apple JavaScriptCore &ndash; Included with Mac OS X</li>
<li>Microsoft Windows Script Host (JScript)</li>
</ul>


<p>So we can use therubyracer gem or  Node.js in with our CentOS and MRI Ruby. In this guide we use <a href="http://nodejs.org/">Nodejs</a> as JavaScript runtime.</p>

<p>Node.js is available from the <a href="https://fedoraproject.org/wiki/EPEL">Fedora Extra Packages for Enterprise Linux (EPEL)</a> repository.</p>

<p>Extra Packages for Enterprise Linux (or EPEL) is a Fedora Special Interest Group that creates, maintains, and manages a high quality set of additional packages for Enterprise Linux, including, but not limited to, Red Hat Enterprise Linux (RHEL), CentOS and Scientific Linux (SL), Oracle Enterprise Linux(OEL).</p>

<p>To check if you have EPEL, run</p>

<pre><code> yum repolist
</code></pre>

<p>if you don&rsquo;t see epel, install it via RPM</p>

<pre><code> rpm -Uvh http://download-i2.fedoraproject.org/pub/epel/6/i386/epel-release-6-8.noarch.rpm
</code></pre>

<p>And then run the following command to install node:</p>

<pre><code> sudo yum install nodejs --enablerepo=epel
</code></pre>

<h2>Step Four &ndash; Install Rails Gem and test it.</h2>

<p> Rails 4.0 needs RubyGems 2.0.3, so you have to update your system by using following command</p>

<pre><code> gem update --system 2.0.3
</code></pre>

<p>Now, you can install the rails gem</p>

<pre><code> gem install rails
 rbenv rehash
</code></pre>

<p>Test your rails:</p>

<pre><code> rails new projectname
 cd projectname
 rails server
</code></pre>

<p>now open your browser and open <a href="http://your-server-ip:3000,you">http://your-server-ip:3000,you</a> can find the rails project default page.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Puma: 一个为并发构建的Ruby服务器]]></title>
    <link href="http://mmclub.github.io/blog/2014/03/03/puma-a-ruby-web-server-for-concurrent/"/>
    <updated>2014-03-03T19:14:42+08:00</updated>
    <id>http://mmclub.github.io/blog/2014/03/03/puma-a-ruby-web-server-for-concurrent</id>
    <content type="html"><![CDATA[<p>本文翻译自Puma官方文档，同时发布于<a href="https://github.com/oa414/puma/blob/master/README.zh.md">Github</a></p>

<p>译者：林翔宇</p>

<h2>概述</h2>

<p>Puma是一个简单，快速，基于线程，并且高并发的面向Ruby/Rack程序的 HTTP 1.1 服务器。Puma同时面向开发和产品环境。为了达到最高的效率，推荐使用一个实现了真正线程的Ruby实现，比如Rubinius或者JRuby。</p>

<h2>为速度和并发构建。</h2>

<p>Puma是一个简单，快速，基于线程，并且高并发的面向Ruby/Rack程序的 HTTP 1.1 服务器。它可以用于任何支持Rack的程序，可以取代Webrick或者Mongrel。它是为了<a href="http://rubini.us">Rubinius</a>而设计的服务器，但是同样可以工作在JRuby和MRI下。Puma同时面向开发和产品环境。</p>

<p>Puam使用了一个继承自Mongrel的C优化的Ragel扩展，来快速并且精确地解析HTTP1.1请求（并且便于移植）。之后，Puma将这些请求放到一个你可以控制的内部线程池的线程之中，所以Puma为你的web应用提供了一个真实的并发环境。</p>

<p>在 Rubinius2.0 中，Puma会用真实的线程利用你所有的CPU核心，这意味着你不用使用多个进程来增加吞吐量。你可以看到在JRuby上类似的优点。</p>

<p>在 MRI中, 因为有全局解释器锁的存在（GIL），同时只能有一个真实的线程在运行。但是当你在做许多IO阻塞的事情的时候（比如HTTP调用像 Twitter的外部API的时候），Puma仍然会通过运行并发运行阻塞的IO调用增加MRI的吞吐量。（ 基于 EventMachine的服务器，如Thin会关掉这个功能，要求你只能使用特别的库）。每个人的选择因实际的应用而异。为了达到最大的吞吐量，强烈推荐使用一个实现了真实线程的Ruby实现，比如<a href="http://rubini.us">Rubinius</a> 或者 <a href="http://jruby.org">JRuby</a>。</p>

<h2>快速入门</h2>

<p>最简单的使用Puma的方式是使用 RubyGems:</p>

<pre><code>$ gem install puma
</code></pre>

<p>现在<code>puma</code>命令已经加入到你的环境变量里了，在你的应用程序根目录下运行下面命令启动你的Rack应用:</p>

<pre><code>$ puma app.ru
</code></pre>

<h2>高级步骤</h2>

<h3>Sinatra</h3>

<p>你可以用下面的命令用Puma运行你的Sinatra应用</p>

<pre><code>$ ruby app.rb -s Puma
</code></pre>

<p>或者在你的应用中设置总是使用Puma</p>

<pre><code>require 'sinatra'
configure { set :server, :puma }
</code></pre>

<p>如果你使用 Bundler,确保你把Puma加入了你的Gemfile中(步骤见下面)。</p>

<h3>Rails</h3>

<p>首先，确保你把Puma加入了你的Gemfile中。</p>

<pre><code>gem 'puma'
</code></pre>

<p>然后用Rails命令启动Puma</p>

<pre><code>$ rails s Puma
</code></pre>

<h3>Rackup</h3>

<p>你可以把Puma作为<code>rackup</code>的选项。</p>

<pre><code>$ rackup -s Puma
</code></pre>

<p>你可以改变你的 <code>config.ru</code> 来默认选择Puma服务器，加入下面的这行:</p>

<pre><code>#\ -s puma
</code></pre>

<h2>配置</h2>

<p>Puma提供了很多控制服务器器运行的选项，完整列表请查阅<code>puma -h</code> (或者 <code>puma --help</code>)</p>

<h3>线程池</h3>

<p>Puma利用了一个你可以改变的动态线程池，你可以通过<code>-t</code> (或者 <code>--threads</code>) 选项:设置最小和最大的线程池里的可以使用的线程数量</p>

<pre><code>$ puma -t 8:32
</code></pre>

<p>Puma会动态的根据当前的负载改变线程数量，默认的数量是<code>0:16</code>, 大胆的尝试吧，但是不要把最大线程数量设置的太大，这会耗尽系统资源。</p>

<h3>集群模式</h3>

<p>Puma 2 提供了集群模式 , 允许你使用 fork出来的进程处理并发处理多个请求。 你可以用-w<code>(or</code>&mdash;workers`) 参数调整运行的work进程数量。</p>

<pre><code>$ puma -t 8:32 -w 3
</code></pre>

<p>在提供真实线程的Ruby实现中，你应该把这个数字调整到和CPU核心数量相同。</p>

<p>注意集群模式下仍然是使用线程的， <code>-t</code> 选项设置每个 worker的进程数量，所以 <code>-w 2 -t 16:16</code> 可能开启了32个线程。</p>

<p>如果你在并发模式你可以选择在启动worker进程前预加载你的应用。如果想利用<a href="https://blog.heroku.com/archives/2013/3/6/matz_highlights_ruby_2_0_at_waza">MRI Ruby 2.0</a>推出的<a href="http://en.wikipedia.org/wiki/Copy-on-write">Copy on Write</a> 的优点的话，这是必要的。只需要调用的时候指定一个 <code>--preload</code> 参数:</p>

<pre><code># CLI invocation
$ puma -t 8:32 -w 3 --preload
</code></pre>

<p>如果你在使用配置文件，使用<code>preload_app!</code>方法，并且使用<code>-C</code>参数指定配置文件:</p>

<pre><code>$ puma -C config/puma.rb

# config/puma.rb
threads 8,32
workers 3
preload_app!
</code></pre>

<p>此外，你可以在配置文件里面定义一个代码块，来在每个工作线程启动的时候运行：</p>

<pre><code># config/puma.rb
on_worker_boot do
  # configuration here
end
</code></pre>

<p>这些代码可以用来在启动应用的时候初始化进程, 允许你做一些和Puma服务器有关，但是不和应用结合的事情。比如，你可以发送一个日志通知Puma启动了。</p>

<p>你可以多次增加钩子调用。</p>

<p>如果你使用ActiveRecord预加载你的应用， 推荐你在这里这样初始化你的连接池：</p>

<pre><code># config/puma.rb
on_worker_boot do
  ActiveSupport.on_load(:active_record) do
    ActiveRecord::Base.establish_connection
  end
end
</code></pre>

<h3>绑定 TCP / Sockets</h3>

<p>相比较其他需要很多配置参数的服务器，Puma仅仅通过<code>-b</code> (或者 <code>--bind</code>)选项使用一个URI参数：</p>

<pre><code>$ puma -b tcp://127.0.0.1:9292
</code></pre>

<p>想通过使用UNIX Sockets来取代TCP么（这能提高5-10%的性能），没问题！</p>

<pre><code>$ puma -b unix:///var/run/puma.sock
</code></pre>

<p>如果你需要改变Unix socket的权限，只需要加入一个umask参数：</p>

<pre><code>$ puma -b 'unix:///var/run/puma.sock?umask=0777'
</code></pre>

<p>希望更加安全？使用 SSL sockets!</p>

<pre><code>$ puma -b 'ssl://127.0.0.1:9292?key=path_to_key&amp;cert=path_to_cert'
</code></pre>

<h3>控制/状态服务</h3>

<p>Puma提供了一个内置的控制/状态服务app来提供对Puam自身的控制，这是一个打开Puma控制服务器的样例：</p>

<pre><code>$ puma --control tcp://127.0.0.1:9293 --control-token foo
</code></pre>

<p>它会在localhost的9293端口打开Puma配置服务器。此外，所有的到控制服务器的请求需要包括一个<code>token=foo</code> 作为查询参数，作为简单的认证。更多app用法参见<a href="https://github.com/puma/puma/blob/master/lib/puma/app/status.rb">status.rb</a>。</p>

<h3>配置文件</h3>

<p>你可以同时使用一个<code>-C</code> (或 <code>--config</code>) 参数提供一个哦诶之文件:</p>

<pre><code>$ puma -C /path/to/config
</code></pre>

<p>请参考 <a href="https://github.com/puma/puma/blob/master/examples/config.rb">示例配置</a> 或者查询 <a href="https://github.com/puma/puma/blob/master/lib/puma/configuration.rb">configuration.rb</a> 查看所有的配置项目</p>

<h2>重启</h2>

<p>Puma有能力在更新版本的时候重启自己，当平台允许的时候(MRI, Rubinius, JRuby),Puma 进行热重启。这是和
 <em>unicorn</em> 和 <em>nginx</em> 在重启的时候保持服务器sockets连接相同的。它可以保证重启的服务器替代旧的服务器的时候请求已经被处理。</p>

<p>Puma有2个内建的重启机制：</p>

<ul>
<li>发送<code>SIGUSR2</code> 信号到<code>puma</code> 进程</li>
<li>使用 status server 和 issue <code>/restart</code></li>
</ul>


<p>当前和重启的进程不会共享代码，所以手动停止Puma并且关闭它也是安全的。</p>

<p>如果新的进程不能加载，它会简单的退出。你应该在生产环境下用一个监控程序运行Puma。</p>

<h3>Cleanup Code</h3>

<p>Puma不能理解所有你的App使用的资源，所以它在你用<code>-C</code>提供的配置文件里面提供了一个叫<code>on_restart</code>的钩子。传递给<code>on_restart</code> 会被Puma在重启自己的时候调用。</p>

<p>你应该在这个代码块里面关闭全局日志文件，redis连接等，这样它们的文件描述符不会在重启的进程里面泄漏。否则会导致文件描述符打开太多，当服务器重启次数很多的时候会导致应用崩溃 。</p>

<h3>平台限制</h3>

<p>不同的平台有差异，下列是Puma在不同平台上有差异的地方</p>

<ul>
<li><strong>JRuby</strong>, <strong>Windows</strong>: 服务器的Socket不能被无缝重启， 这些平台不能通过Ruby传递信息到新的进程</li>
<li><strong>JRuby</strong>, <strong>Windows</strong>: 不支持集群模式 ，因为没有fork  fork(2)</li>
<li><strong>Windows</strong>: 不支持daemon mode ，因为没有fork(2)</li>
</ul>


<h2>pumactl</h2>

<p><code>pumactl</code> 是一个简单的CLI前端来控制或者查看上述的app状态。 请参考  <code>pumactl --help</code></p>

<h2>维护多个Puma  / init.d / upstart 脚本</h2>

<p>如果你想马上得到一个维护多个程序的脚本，请查看用于init.d 和 upstart脚本的<a href="https://github.com/puma/puma/tree/master/tools/jungle">tools/jungle</a></p>

<h2>Capistrano 部署</h2>

<p>Puma 已经被包括进 Capistrano <a href="https://github.com/puma/puma/blob/master/lib/puma/capistrano.rb">deploy script</a>, 你只要 require :</p>

<p>config/deploy.rb</p>

<p><code>ruby
require 'puma/capistrano'
</code></p>

<p>然后</p>

<p><code>bash
$ bundle exec cap puma:start
$ bundle exec cap puma:restart
$ bundle exec cap puma:stop
$ bundle exec cap puma:phased_restart
</code></p>

<h2>协议</h2>

<p>Puma 的版权属于Evan Phoenix 和 贡献者. 它基于BSD 协议. 详见LICENSE文件。</p>
]]></content>
  </entry>
  
</feed>
