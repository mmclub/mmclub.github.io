<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 林翔宇 | 南京邮电大学移动互联网俱乐部]]></title>
  <link href="http://mmclub.github.io/blog/categories/lin-xiang-yu/atom.xml" rel="self"/>
  <link href="http://mmclub.github.io/"/>
  <updated>2014-03-30T16:51:10+08:00</updated>
  <id>http://mmclub.github.io/</id>
  <author>
    <name><![CDATA[MMClub]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[How to Install Ruby on Rails on CentOS 6.5 Using Rbenv]]></title>
    <link href="http://mmclub.github.io/blog/2014/03/30/install-ruby-on-rails-on-centos/"/>
    <updated>2014-03-30T11:11:37+08:00</updated>
    <id>http://mmclub.github.io/blog/2014/03/30/install-ruby-on-rails-on-centos</id>
    <content type="html"><![CDATA[<h2>Introduction</h2>

<h3>Ruby on Rails</h3>

<p>Ruby on Rails is one of the most popular web development framework, it&rsquo;s build upon  Ruby Programming Language, and it&rsquo;s the hottest web development stack currently.</p>

<h3>Rbenv</h3>

<p><a href="https://github.com/sstephenson/rbenv">Rbenv</a> is a shell script tools created by <a href="http://sstephenson.us/">Sam Stephenson</a>. It&rsquo;s used for groom your app’s Ruby environment.Use rbenv can pick a Ruby version for your application and guarantee that your development environment matches production.</p>

<p>rbenv works by inserting a directory of shims at the front of your PATH:</p>

<pre><code> ~/.rbenv/shims:/usr/local/bin:/usr/bin:/bin
</code></pre>

<p>Through a process called rehashing, rbenv maintains shims in that directory to match every Ruby command across every installed version of Ruby—irb, gem, rake, rails, ruby, and so on.</p>

<h3>CentOS</h3>

<p>CentOS is derived from  Red Hat Enterprise Linux. The target users of these distributions are usually businesses, which require their systems to be running the most stable way for a long time.So we are going to use  CentOS 6.5 running our applications.</p>

<h2>Step One &ndash; Install dependencies</h2>

<p>Before, installing any package, it&rsquo;s always recommended to update package repository cache use yum.</p>

<pre><code> sudo yum update
</code></pre>

<p>Now,in order to get necessary development tools and dependencies, run the following:</p>

<pre><code> sudo yum groupinstall -y 'development tools'
 sudo yum install -y gcc-c++ glibc-headers openssl-devel readline libyaml-devel readline-devel zlib zlib-devel  sqlite-devel  
</code></pre>

<h2>Step Two &ndash; Install Rbenv and ruby-build</h2>

<p>Then we are ready to get Rbenv downloaded installed, run the following to check out rbenv into ~/.rbenv:</p>

<pre><code> git clone git://github.com/sstephenson/rbenv.git ~/.rbenv
</code></pre>

<p>Add ~/.rbenv/bin to your $PATH for access to the rbenv command-line utility:</p>

<pre><code> echo 'export PATH="$HOME/.rbenv/bin:$PATH"' &gt;&gt; ~/.bash_profile
</code></pre>

<p>Add rbenv init to your shell to enable rbenv shims and autocompletion.</p>

<pre><code> echo 'eval "$(rbenv init -)"' &gt;&gt; ~/.bash_profile
</code></pre>

<p>Ruby-build is a Rbenv plugin which provides the rbenv install command that simplifies the process of installing new Ruby versions. Install rbenv-build:</p>

<pre><code> git clone https://github.com/sstephenson/ruby-build.git ~/.rbenv/plugins/ruby-build
</code></pre>

<p>reloaded your bash_profile to enable rbenv command:</p>

<pre><code> source ~/.bash_profile
</code></pre>

<h2>Step Three &ndash; Install Ruby</h2>

<p>Install Ruby 2.1.0 and make it the default</p>

<pre><code> rbenv install 2.1.0
 rbenv rehash
 rbenv global 2.1.0
</code></pre>

<p>Now you can run:</p>

<pre><code> ruby -v
</code></pre>

<p>to verify your ruby environment has been installed successful。 It will output something like this:</p>

<pre><code> ruby 2.1.0p0 (2013-12-25 revision 44422) [x86_64-linux]
</code></pre>

<h2>Step Four &ndash; Install Nodejs</h2>

<p>Ruby on Rails need a JavaScript runtime support. It use <a href="https://github.com/sstephenson/execjs">execjs</a> gem which can automatically picks the best runtime available to evaluate your JavaScript program, then returns the result to you as a Ruby object.</p>

<p>ExecJS supports these runtimes:</p>

<ul>
<li>therubyracer &ndash; Google V8 embedded within Ruby</li>
<li>therubyrhino &ndash; Mozilla Rhino embedded within JRuby</li>
<li>Node.js</li>
<li>Apple JavaScriptCore &ndash; Included with Mac OS X</li>
<li>Microsoft Windows Script Host (JScript)</li>
</ul>


<p>So we can use therubyracer gem or  Node.js in with our CentOS and MRI Ruby. In this guide we use <a href="http://nodejs.org/">Nodejs</a> as JavaScript runtime.</p>

<p>Node.js is available from the <a href="https://fedoraproject.org/wiki/EPEL">Fedora Extra Packages for Enterprise Linux (EPEL)</a> repository.</p>

<p>Extra Packages for Enterprise Linux (or EPEL) is a Fedora Special Interest Group that creates, maintains, and manages a high quality set of additional packages for Enterprise Linux, including, but not limited to, Red Hat Enterprise Linux (RHEL), CentOS and Scientific Linux (SL), Oracle Enterprise Linux(OEL).</p>

<p>To check if you have EPEL, run</p>

<pre><code> yum repolist
</code></pre>

<p>if you don&rsquo;t see epel, install it via RPM</p>

<pre><code> rpm -Uvh http://download-i2.fedoraproject.org/pub/epel/6/i386/epel-release-6-8.noarch.rpm
</code></pre>

<p>And then run the following command to install node:</p>

<pre><code> sudo yum install nodejs --enablerepo=epel
</code></pre>

<h2>Step Four &ndash; Install Rails Gem and test it.</h2>

<p> Rails 4.0 needs RubyGems 2.0.3, so you have to update your system by using following command</p>

<pre><code> gem update --system 2.0.3
</code></pre>

<p>Now, you can install the rails gem</p>

<pre><code> gem install rails
 rbenv rehash
</code></pre>

<p>Test your rails:</p>

<pre><code> rails new projectname
 cd projectname
 rails server
</code></pre>

<p>now open your browser and open <a href="http://your-server-ip:3000,you">http://your-server-ip:3000,you</a> can find the rails project default page.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Puma: 一个为并发构建的Ruby服务器]]></title>
    <link href="http://mmclub.github.io/blog/2014/03/03/puma-a-ruby-web-server-for-concurrent/"/>
    <updated>2014-03-03T19:14:42+08:00</updated>
    <id>http://mmclub.github.io/blog/2014/03/03/puma-a-ruby-web-server-for-concurrent</id>
    <content type="html"><![CDATA[<p>本文翻译自Puma官方文档，同时发布于<a href="https://github.com/oa414/puma/blob/master/README.zh.md">Github</a></p>

<p>译者：林翔宇</p>

<h2>概述</h2>

<p>Puma是一个简单，快速，基于线程，并且高并发的面向Ruby/Rack程序的 HTTP 1.1 服务器。Puma同时面向开发和产品环境。为了达到最高的效率，推荐使用一个实现了真正线程的Ruby实现，比如Rubinius或者JRuby。</p>

<h2>为速度和并发构建。</h2>

<p>Puma是一个简单，快速，基于线程，并且高并发的面向Ruby/Rack程序的 HTTP 1.1 服务器。它可以用于任何支持Rack的程序，可以取代Webrick或者Mongrel。它是为了<a href="http://rubini.us">Rubinius</a>而设计的服务器，但是同样可以工作在JRuby和MRI下。Puma同时面向开发和产品环境。</p>

<p>Puam使用了一个继承自Mongrel的C优化的Ragel扩展，来快速并且精确地解析HTTP1.1请求（并且便于移植）。之后，Puma将这些请求放到一个你可以控制的内部线程池的线程之中，所以Puma为你的web应用提供了一个真实的并发环境。</p>

<p>在 Rubinius2.0 中，Puma会用真实的线程利用你所有的CPU核心，这意味着你不用使用多个进程来增加吞吐量。你可以看到在JRuby上类似的优点。</p>

<p>在 MRI中, 因为有全局解释器锁的存在（GIL），同时只能有一个真实的线程在运行。但是当你在做许多IO阻塞的事情的时候（比如HTTP调用像 Twitter的外部API的时候），Puma仍然会通过运行并发运行阻塞的IO调用增加MRI的吞吐量。（ 基于 EventMachine的服务器，如Thin会关掉这个功能，要求你只能使用特别的库）。每个人的选择因实际的应用而异。为了达到最大的吞吐量，强烈推荐使用一个实现了真实线程的Ruby实现，比如<a href="http://rubini.us">Rubinius</a> 或者 <a href="http://jruby.org">JRuby</a>。</p>

<h2>快速入门</h2>

<p>最简单的使用Puma的方式是使用 RubyGems:</p>

<pre><code>$ gem install puma
</code></pre>

<p>现在<code>puma</code>命令已经加入到你的环境变量里了，在你的应用程序根目录下运行下面命令启动你的Rack应用:</p>

<pre><code>$ puma app.ru
</code></pre>

<h2>高级步骤</h2>

<h3>Sinatra</h3>

<p>你可以用下面的命令用Puma运行你的Sinatra应用</p>

<pre><code>$ ruby app.rb -s Puma
</code></pre>

<p>或者在你的应用中设置总是使用Puma</p>

<pre><code>require 'sinatra'
configure { set :server, :puma }
</code></pre>

<p>如果你使用 Bundler,确保你把Puma加入了你的Gemfile中(步骤见下面)。</p>

<h3>Rails</h3>

<p>首先，确保你把Puma加入了你的Gemfile中。</p>

<pre><code>gem 'puma'
</code></pre>

<p>然后用Rails命令启动Puma</p>

<pre><code>$ rails s Puma
</code></pre>

<h3>Rackup</h3>

<p>你可以把Puma作为<code>rackup</code>的选项。</p>

<pre><code>$ rackup -s Puma
</code></pre>

<p>你可以改变你的 <code>config.ru</code> 来默认选择Puma服务器，加入下面的这行:</p>

<pre><code>#\ -s puma
</code></pre>

<h2>配置</h2>

<p>Puma提供了很多控制服务器器运行的选项，完整列表请查阅<code>puma -h</code> (或者 <code>puma --help</code>)</p>

<h3>线程池</h3>

<p>Puma利用了一个你可以改变的动态线程池，你可以通过<code>-t</code> (或者 <code>--threads</code>) 选项:设置最小和最大的线程池里的可以使用的线程数量</p>

<pre><code>$ puma -t 8:32
</code></pre>

<p>Puma会动态的根据当前的负载改变线程数量，默认的数量是<code>0:16</code>, 大胆的尝试吧，但是不要把最大线程数量设置的太大，这会耗尽系统资源。</p>

<h3>集群模式</h3>

<p>Puma 2 提供了集群模式 , 允许你使用 fork出来的进程处理并发处理多个请求。 你可以用-w<code>(or</code>&mdash;workers`) 参数调整运行的work进程数量。</p>

<pre><code>$ puma -t 8:32 -w 3
</code></pre>

<p>在提供真实线程的Ruby实现中，你应该把这个数字调整到和CPU核心数量相同。</p>

<p>注意集群模式下仍然是使用线程的， <code>-t</code> 选项设置每个 worker的进程数量，所以 <code>-w 2 -t 16:16</code> 可能开启了32个线程。</p>

<p>如果你在并发模式你可以选择在启动worker进程前预加载你的应用。如果想利用<a href="https://blog.heroku.com/archives/2013/3/6/matz_highlights_ruby_2_0_at_waza">MRI Ruby 2.0</a>推出的<a href="http://en.wikipedia.org/wiki/Copy-on-write">Copy on Write</a> 的优点的话，这是必要的。只需要调用的时候指定一个 <code>--preload</code> 参数:</p>

<pre><code># CLI invocation
$ puma -t 8:32 -w 3 --preload
</code></pre>

<p>如果你在使用配置文件，使用<code>preload_app!</code>方法，并且使用<code>-C</code>参数指定配置文件:</p>

<pre><code>$ puma -C config/puma.rb

# config/puma.rb
threads 8,32
workers 3
preload_app!
</code></pre>

<p>此外，你可以在配置文件里面定义一个代码块，来在每个工作线程启动的时候运行：</p>

<pre><code># config/puma.rb
on_worker_boot do
  # configuration here
end
</code></pre>

<p>这些代码可以用来在启动应用的时候初始化进程, 允许你做一些和Puma服务器有关，但是不和应用结合的事情。比如，你可以发送一个日志通知Puma启动了。</p>

<p>你可以多次增加钩子调用。</p>

<p>如果你使用ActiveRecord预加载你的应用， 推荐你在这里这样初始化你的连接池：</p>

<pre><code># config/puma.rb
on_worker_boot do
  ActiveSupport.on_load(:active_record) do
    ActiveRecord::Base.establish_connection
  end
end
</code></pre>

<h3>绑定 TCP / Sockets</h3>

<p>相比较其他需要很多配置参数的服务器，Puma仅仅通过<code>-b</code> (或者 <code>--bind</code>)选项使用一个URI参数：</p>

<pre><code>$ puma -b tcp://127.0.0.1:9292
</code></pre>

<p>想通过使用UNIX Sockets来取代TCP么（这能提高5-10%的性能），没问题！</p>

<pre><code>$ puma -b unix:///var/run/puma.sock
</code></pre>

<p>如果你需要改变Unix socket的权限，只需要加入一个umask参数：</p>

<pre><code>$ puma -b 'unix:///var/run/puma.sock?umask=0777'
</code></pre>

<p>希望更加安全？使用 SSL sockets!</p>

<pre><code>$ puma -b 'ssl://127.0.0.1:9292?key=path_to_key&amp;cert=path_to_cert'
</code></pre>

<h3>控制/状态服务</h3>

<p>Puma提供了一个内置的控制/状态服务app来提供对Puam自身的控制，这是一个打开Puma控制服务器的样例：</p>

<pre><code>$ puma --control tcp://127.0.0.1:9293 --control-token foo
</code></pre>

<p>它会在localhost的9293端口打开Puma配置服务器。此外，所有的到控制服务器的请求需要包括一个<code>token=foo</code> 作为查询参数，作为简单的认证。更多app用法参见<a href="https://github.com/puma/puma/blob/master/lib/puma/app/status.rb">status.rb</a>。</p>

<h3>配置文件</h3>

<p>你可以同时使用一个<code>-C</code> (或 <code>--config</code>) 参数提供一个哦诶之文件:</p>

<pre><code>$ puma -C /path/to/config
</code></pre>

<p>请参考 <a href="https://github.com/puma/puma/blob/master/examples/config.rb">示例配置</a> 或者查询 <a href="https://github.com/puma/puma/blob/master/lib/puma/configuration.rb">configuration.rb</a> 查看所有的配置项目</p>

<h2>重启</h2>

<p>Puma有能力在更新版本的时候重启自己，当平台允许的时候(MRI, Rubinius, JRuby),Puma 进行热重启。这是和
 <em>unicorn</em> 和 <em>nginx</em> 在重启的时候保持服务器sockets连接相同的。它可以保证重启的服务器替代旧的服务器的时候请求已经被处理。</p>

<p>Puma有2个内建的重启机制：</p>

<ul>
<li>发送<code>SIGUSR2</code> 信号到<code>puma</code> 进程</li>
<li>使用 status server 和 issue <code>/restart</code></li>
</ul>


<p>当前和重启的进程不会共享代码，所以手动停止Puma并且关闭它也是安全的。</p>

<p>如果新的进程不能加载，它会简单的退出。你应该在生产环境下用一个监控程序运行Puma。</p>

<h3>Cleanup Code</h3>

<p>Puma不能理解所有你的App使用的资源，所以它在你用<code>-C</code>提供的配置文件里面提供了一个叫<code>on_restart</code>的钩子。传递给<code>on_restart</code> 会被Puma在重启自己的时候调用。</p>

<p>你应该在这个代码块里面关闭全局日志文件，redis连接等，这样它们的文件描述符不会在重启的进程里面泄漏。否则会导致文件描述符打开太多，当服务器重启次数很多的时候会导致应用崩溃 。</p>

<h3>平台限制</h3>

<p>不同的平台有差异，下列是Puma在不同平台上有差异的地方</p>

<ul>
<li><strong>JRuby</strong>, <strong>Windows</strong>: 服务器的Socket不能被无缝重启， 这些平台不能通过Ruby传递信息到新的进程</li>
<li><strong>JRuby</strong>, <strong>Windows</strong>: 不支持集群模式 ，因为没有fork  fork(2)</li>
<li><strong>Windows</strong>: 不支持daemon mode ，因为没有fork(2)</li>
</ul>


<h2>pumactl</h2>

<p><code>pumactl</code> 是一个简单的CLI前端来控制或者查看上述的app状态。 请参考  <code>pumactl --help</code></p>

<h2>维护多个Puma  / init.d / upstart 脚本</h2>

<p>如果你想马上得到一个维护多个程序的脚本，请查看用于init.d 和 upstart脚本的<a href="https://github.com/puma/puma/tree/master/tools/jungle">tools/jungle</a></p>

<h2>Capistrano 部署</h2>

<p>Puma 已经被包括进 Capistrano <a href="https://github.com/puma/puma/blob/master/lib/puma/capistrano.rb">deploy script</a>, 你只要 require :</p>

<p>config/deploy.rb</p>

<p><code>ruby
require 'puma/capistrano'
</code></p>

<p>然后</p>

<p><code>bash
$ bundle exec cap puma:start
$ bundle exec cap puma:restart
$ bundle exec cap puma:stop
$ bundle exec cap puma:phased_restart
</code></p>

<h2>协议</h2>

<p>Puma 的版权属于Evan Phoenix 和 贡献者. 它基于BSD 协议. 详见LICENSE文件。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android反编译入门与反编译防范]]></title>
    <link href="http://mmclub.github.io/blog/2014/03/02/decompile-in-android/"/>
    <updated>2014-03-02T22:04:22+08:00</updated>
    <id>http://mmclub.github.io/blog/2014/03/02/decompile-in-android</id>
    <content type="html"><![CDATA[<p>作者: 林翔宇</p>

<h2>反编译Java代码</h2>

<p>参考<a href="http://www.oschina.net/question/54100_33457">http://www.oschina.net/question/54100_33457</a></p>

<p>文中给出下载链接版本较老，其中dex2jar可能会出现java.lang.OutOfMemoryError的异常。请去官网下载两个工具的最新版。</p>

<ul>
<li><a href="https://code.google.com/p/dex2jar/">https://code.google.com/p/dex2jar/</a></li>
<li><a href="http://java.decompiler.free.fr/?q=jdgui">http://java.decompiler.free.fr/?q=jdgui</a></li>
</ul>


<p>简单来说，用dex2jar把apk文件解压得到的classes.dex转化为jar文件，然后用JD-GUI打开这个Jar文件，查看源码。</p>

<h2>反编译apk生成程序的源代码和图片、XML配置、语言资源等文件</h2>

<p>同样参考<a href="http://www.oschina.net/question/54100_33457">http://www.oschina.net/question/54100_33457</a></p>

<p>使用apktool <a href="https://code.google.com/p/android-apktool/">https://code.google.com/p/android-apktool/</a></p>

<h2>混淆代码防范反编译</h2>

<p>参考 <a href="http://blog.csdn.net/sunboy_2050/article/details/6727640">http://blog.csdn.net/sunboy_2050/article/details/6727640</a></p>

<p><em>2014.3.4更新，感谢俱乐部苏东生同学在评论区提醒</em></p>

<p>新版的SDK在创建工程目录的时候已经提供了默认的模板，将project.properties的中“# proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt”的“#”去掉，再做一些定制就可以了。可以参考</p>

<p><a href="http://blog.csdn.net/brokge/article/details/8989312">http://blog.csdn.net/brokge/article/details/8989312</a></p>

<p><del>修改Android项目下default.properties文件，加上一句proguard.config=proguard.cfg。</del></p>

<p><del>当然同时目录下要有proguard.cfg文件，可以在android_sdk_path/tools/proguard/目录下找</del></p>

<p><del>其实似乎现在Android默认创建工程的时候就已经有了。。看一下default.properties注释就可以了。。。</del></p>

<p><em>注意</em></p>

<p>参考<a href="http://my.oschina.net/banxi/blog/55622">http://my.oschina.net/banxi/blog/55622</a></p>

<ul>
<li>当使用了除了android-support-v4这些API的时候，要添加相对应的声明</li>
<li>可以让proguard帮我们忽略Log.d()这些语句</li>
</ul>


<h2>其他参考资料</h2>

<ul>
<li><a href="http://www.google.co.uk/search?hl=zh-CN&amp;newwindow=1&amp;site=&amp;source=hp&amp;q=Android++decomplier&amp;btnG=Google+%E6%90%9C%E7%B4%A2">Google搜索Android  decomplier</a></li>
<li><a href="http://stackoverflow.com/questions/1249973/decompiling-dex-into-java-sourcecode">StackOverFlow decompiling DEX into Java sourcecode</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android测试入门(一) Activity测试简介]]></title>
    <link href="http://mmclub.github.io/blog/2014/03/02/android-test-1/"/>
    <updated>2014-03-02T21:54:03+08:00</updated>
    <id>http://mmclub.github.io/blog/2014/03/02/android-test-1</id>
    <content type="html"><![CDATA[<p>作者：林翔宇</p>

<h2>瞎扯</h2>

<p>什么是测试？试想大家写一个程序的时候，经常要手动在命令行下输入测试数据，然后看看程序的输出与实际一不一致。而在做App等UI事件众多的程序的时候，经常要手动点击按钮等控件，看看会不会有预期一样的反应。</p>

<p>大家每次都这样做，累不累呢～有什么好方法可以帮我们节约这些时间从而省出更多时间来约漂亮的女孩子呢～</p>

<p>当然有咯。我们再写一个程序，把这些步骤自动化就行咯。这个程序就是一个测试。</p>

<p>当然软件测试包含的东西很多，我们就来简单扯扯Android测试相关的内容，分几期做一个简单的入门介绍。</p>

<h2>简介</h2>

<p><a href="https://developer.android.com/tools/testing/index.html">Official Doc</a></p>

<p>Android SDK包含了强大的测试工具</p>

<ul>
<li>一个Android Test本身是一个Android Application，并且它的AndroidManifest.xml文件里面有它测试目标的信息</li>
<li>与一个Application不同，Android Test由多个测试用例组成，而不是Android components。</li>
<li>Android测试拥立扩展自JUnit TestCase类，并且可以在测试时发送触摸和键盘输入信息</li>
<li>根据不同的component (application, activity, content provider, or service)，你可以选择不同的Android test 基类</li>
<li>Eclipese/ADT, Intellij IDEA, Android Studio均提供了和Android Test的良好整合</li>
</ul>


<p>一个 Test Application包含了以下几种对于Activity相关的测试</p>

<ul>
<li>启动的初始化状态测试，比如测试一个UI控件是否成功实例化，会不会返回空指针。</li>
<li>UI测试，比如测试按钮点击出现的结果与预期比较一不一样</li>
<li>状态转移时候的测试，当一个Activity在Pause，Start等几个状态之间变换的时候，测试有的控件，变量。</li>
</ul>


<h2>新建一个测试</h2>

<p>在Intellij IDEA中，可以在项目文件下 File &ndash; New Module &ndash; Android Test Module来创建一个测试</p>

<p><img src="http://i.imgur.com/z5M4eF5.png" alt="Intellij New Test Module" /></p>

<p>Intellij IDEA会生成一个类似下面的程序结构</p>

<p>```</p>

<p>MMDailyTest
├── AndroidManifest.xml
├── MMDailyTest.iml
├── ant.properties
├── bin
├── build.xml
├── gen
│   └── org
│       └── nupter
│           └── mmdaily
│               └── tests
│                   ├── BuildConfig.java
│                   ├── Manifest.java
│                   └── R.java
├── libs
├── local.properties
├── proguard-project.txt
├── project.properties
├── res
└── src</p>

<pre><code>└── org
    └── nupter
        └── mmdaily
            ├── api
            └── ui
                └── ActivityListActivityTest.java
</code></pre>

<p>```</p>

<p>和一个Android App目录基本一致</p>

<p>来看看 AndroidManifest.xml 有什么东西</p>

<p>```xml</p>

<p>&lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;utf-8&rdquo;?></p>

<!-- package name must be unique so suffix with "tests" so package loader doesn't ignore us -->


<p>&lt;manifest xmlns:android=&ldquo;<a href="http://schemas.android.com/apk/res/android">http://schemas.android.com/apk/res/android</a>&rdquo;</p>

<pre><code>      package="org.nupter.mmdaily.tests"
      android:versionCode="1"
      android:versionName="1.0"&gt;
&lt;!-- We add an application tag here just so that we can indicate that
     this package needs to link against the android.test library,
     which is needed when building test cases. --&gt;
&lt;application&gt;
    &lt;uses-library android:name="android.test.runner"/&gt;
&lt;/application&gt;
&lt;!--
This declares that this application uses the instrumentation test runner targeting
the package of org.nupter.mmdaily.  To run the tests use the command:
"adb shell am instrument -w org.nupter.mmdaily.tests/android.test.InstrumentationTestRunner"
--&gt;
&lt;instrumentation android:name="android.test.InstrumentationTestRunner"
                 android:targetPackage="org.nupter.mmdaily"
                 android:label="Tests for org.nupter.mmdaily"/&gt;
</code></pre>

<p></manifest></p>

<p>```</p>

<p>默认生成的注释写得很清楚，相比普通的App的AndroidManifest.xml ，多了一个android:name=&ldquo;android.test.runner"的library依赖，以及一个instrumentation元素，制定了测试的对象的包。</p>

<h2>第一个测试类</h2>

<p>一个测试首先是一个继承自<code>android.test.ActivityInstrumentationTestCase2&lt;YOUR_ACTIVITY_CLASS&gt;</code> 的类</p>

<p>比如我们为ReadPageActivity创建一个ReadPageActivityTest.java</p>

<p>这个ReadPageActivity里面只有一个显示为返回的Button，我们测试按这个按钮的反应，以及这个按钮的文字是不是一直显示为Button</p>

<p>```java</p>

<p>package org.nupter.mmdaily.ui;</p>

<p>import android.app.Instrumentation;
import android.test.ActivityInstrumentationTestCase2;
import android.widget.Button;
import org.nupter.mmdaily.R;</p>

<p>/<em>*
 * Author: linxiangyu
 * Date:   3/2/14
 * Time:   3:24 AM
 </em>/
public class ReadPageActivityTest extends ActivityInstrumentationTestCase2<ReadPageActivity> {</p>

<pre><code>/**
 * 一个Android Activity的Example，是&lt;a href="https://developer.android.com/tools/testing/testing_android.html"&gt;官方教程的简化版&lt;/a&gt;
 */

private ReadPageActivity mActivity;
private Button mButton;


public ReadPageActivityTest() {
    super(ReadPageActivity.class);    // 整个测试开始之前构建的初始化条件。注意这个构造函数的样子，写错了运行测试的时候这个类就不会被调用了
}

@Override
public void setUp() throws Exception {
    super.setUp();       // 每个TestCase开始之前都会调用，在这里初始化一些成员变量，可以避免TestCase对变量的修改的影响

    setActivityInitialTouchMode(false); //如果你的测试要触发触摸或者键盘输入，那么必须手动关闭掉Touch Mode

    mActivity = getActivity();    // 获取activity

    mButton = (Button) mActivity.findViewById(
           R.id.ReadPageBack
    );

}

@Override
public void tearDown() throws Exception {
    super.tearDown();    // 每个TestCase结束之后都会调用
}



public void testPreConditions() {
    assertTrue(mButton != null);
} // 测试一些初始条件，比如你的UI控件不为空。


public void testBaseUI(){
    assertEquals(mButton.getText(), "返回");
    mActivity.runOnUiThread(
            new Runnable() {
                public void run() {
                    mButton.requestFocus();
                    mButton.callOnClick();
                } //
            }); // UI控件的改变必须这样运行在一个runOnUiThread 中

}  // 测试一些UI事件

public void testStatePause() {
    Instrumentation mInstr = this.getInstrumentation();
    mInstr.callActivityOnPause(mActivity);
    assertEquals(mButton.getText(), "返回");
} // 测试一些App状态转移的时候的样子
</code></pre>

<p>}</p>

<p>```</p>

<h3>运行测试</h3>

<p><img src="http://i.imgur.com/1VWC6oS.png" alt="Run Test" /></p>

<p>你会在Intellij 下面的Run窗口里面看到相关的提示，以及你的模拟器/手机迅速跳转到相应的测试Activity，然后又返回来。</p>

<p><img src="http://i.imgur.com/oTD4PMs.png" alt="Test Result" /></p>

<p>很高兴，测试一次通过，全绿。</p>

<h3>项目代码</h3>

<p><a href="https://github.com/mmclub/MMDaily/tree/23ee19d4b25889a5a112f4f6d39e4d306fc8d82b">项目的代码</a></p>

<p>这就是一个最简单的Android测试的样例了，之后我们会介绍其他Android SDK里面测试相关的东西。</p>
]]></content>
  </entry>
  
</feed>
